内核与应用程序
===============

系统内核
---------

系统内核是指大多数操作系统的核心部分。它由操作系统中用于管理存储器、文件、外设和系统资源的那些部分组成。操作系统内核通常运行进程，并提供进程间的通信。

牛津字典中对"kernel"一词的定义是："较软的、通常是一个坚果可食用的部分。"当然还有第二种定义："某个东西核心或者最重要的部分。"对Linux来说，它的Kernel无疑属于第二种解释。让我们来看看这个重要的东西是如何工作的，先从一点理论说起。

广义地来说kernel就是一个软件，它在硬件和运行在计算机(电脑)上的应用程序之间提供了一个层。严格点从计算机科学的角度来说，Linux中的Kernel指的是Linus Torvalds在90年代初期写的那点代码。

所有的你在Linux各版本中看到的其他东西 Bash shell、KDE窗口管理器、web浏览器、X服务器、Tux Racer以及所有的其他，都不过是运行在Linux上的应用而已，而不是操作系统自身的一部分。为了给大家一个更加直观的感觉，我们来举个例子，比如 *RHEL5* [#rhel5]_ 的安装大概要占据2.5GB的硬盘空间（具体多大当然视你的选择安装来定），在这其中，kernel以及它的各个模块组件，只有47MB，所占比例约为2%。

那么kernel到底是如何工作的呢？。Kernel通过许多进入的端口——系统调用，来使得运行在它上面的应用程序可用。

直接对硬件操作是非常复杂的，所以内核通常提供一种硬件抽象的方法来完成这些操作。硬件抽象隐藏了复杂性，为应用软件和硬件提供了一套简洁，统一的接口，使程序设计更为简单。

Kernel提供的更明显的抽象之一是文件系统。举例来说，这里有一段短的程序是用C写的，它打开了一个文件，读取第一行并打印 

.. code-block :: c

	#include <stdio.h>
	int main()
	{
	    FILE *fp=NULL;
	    char buf[50];
	    
	    fp = fopen("/tmp/text.log","r");
	    fgets(buf,50,fp);
	    fclose(fp);
	    
	    printf("Read file #1 line: %s",buf);
	    return 0;
	}

在这里，你可以看到四个系统调用的例子：打开、读、写和关闭。不谈这段程序语法的细节，重点是：通过这些系统调用，Linux Kernel提供了一个文件的"错觉"，屏蔽了读写文件时计算机底层的运作，而是直接以例子中的方式与硬件"交流"，这也就是我们所说的抽象（abstraction），将底层的东西以更易懂的方式表达出来。


应用程序
----------

？

系统调用
---------

什么是系统调用
^^^^^^^^^^^^^^^^

在Linux的世界里，我们经常会遇到系统调用这一术语。系统调用，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。

从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。

系统服务之所以需要通过系统调用来提供给用户空间的根本原因是为了对系统进行“保护”。因为Linux的运行空间分为 *内核空间与用户空间* [#内核空间与用户空间]_ ，它们各自运行在不同的级别中，逻辑上相互隔离。所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用用户空间函数。比如我们熟悉的“hello world”程序（执行时）就是标准的用户空间进程，它使用的打印函数printf就属于用户空间函数，打印的字符“hello word”字符串也属于用户空间数据。

但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊接口”—— 系统调用了。它的特殊性主要在于规定了用户进程进入内核的具体位置；换句话说，用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无虞。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实地坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。

Linux 的系统调用
^^^^^^^^^^^^^^^^^

对于现代操作系统，系统调用是一种内核与用户空间通讯的普遍手段，Linux系统也不例外。但是Linux系统的系统调用相比很多Unix和windows等系统具有一些独特之处，无处不体现出Linux的设计精髓——简洁和高效。

Linux系统调用很多地方继承了Unix的系统调用（但不是全部），但Linux相比传统Unix的系统调用做了很多扬弃，它省去了许多Unix系统冗余的系统调用，仅仅保留了最基本和最有用的系统调用，所以Linux全部系统调用只有250个左右（而有些操作系统系统调用多达1000个以上）。

这些系统调用按照功能逻辑大致可分为

* 进程控制
* 文件系统控制
* 系统控制
* 存储管理
* 网络管理
* socket控制
* 用户管理
* 进程间通信

等几类。

总的概括来讲，系统调用在系统中的主要用途无非以下几类：

* 控制硬件
	系统调用往往作为硬件资源和用户空间的抽象接口，比如读写文件时用到的write/read调用。
* 设置系统状态或读取内核数据
	因为系统调用是用户空间和内核的唯一通讯手段，所以用户设置系统状态，比如开/关某项内核服务（设置某个内核变量），或读取内核数据都必须通过系统调用。
* 进程管理
	保证系统中进程能多任务运行。

.. rubric :: 脚注

.. [#rhel5] 一个流行的Linux发行版
.. [#内核空间与用户空间] 详见第x章论述