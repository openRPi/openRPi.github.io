<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. 附录 - GPIO Interfaces &mdash; 简明 Linux GPIO驱动指导 1.0.0 文档</title>
    
    <link rel="stylesheet" href="static/nature_overwrite.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="static/translations.js"></script>
    <link rel="top" title="简明 Linux GPIO驱动指导 1.0.0 文档" href="index.html" />
    <link rel="next" title="6. 附录 - 树莓派GPIO编号" href="附录-树莓派GPIO编号.html" />
    <link rel="prev" title="4. 真正的GPIO内核驱动" href="C3_真正的GPIO内核驱动.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="附录-树莓派GPIO编号.html" title="6. 附录 - 树莓派GPIO编号"
             accesskey="N">下一页</a></li>
        <li class="right" >
          <a href="C3_真正的GPIO内核驱动.html" title="4. 真正的GPIO内核驱动"
             accesskey="P">上一页</a> |</li>
        <li><a href="index.html">简明 Linux GPIO驱动指导 1.0.0 文档</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="gpio-interfaces">
<h1>5. 附录 - GPIO Interfaces<a class="headerlink" href="#gpio-interfaces" title="永久链接至标题">¶</a></h1>
<p>This provides an overview of GPIO access conventions on Linux.</p>
<p>These calls use the <tt class="docutils literal"><span class="pre">gpio_*</span></tt> naming prefix.  No other calls should use that
prefix, or the related <tt class="docutils literal"><span class="pre">__gpio_*</span></tt> prefix.</p>
<div class="section" id="what-is-a-gpio">
<h2>5.1. What is a GPIO?<a class="headerlink" href="#what-is-a-gpio" title="永久链接至标题">¶</a></h2>
<p>A &#8220;General Purpose Input/Output&#8221; (GPIO) is a flexible software-controlled
digital signal.  They are provided from many kinds of chip, and are familiar
to Linux developers working with embedded and custom hardware.  Each GPIO
represents a bit connected to a particular pin, or &#8220;ball&#8221; on Ball Grid Array
(BGA) packages.  Board schematics show which external hardware connects to
which GPIOs.  Drivers can be written generically, so that board setup code
passes such pin configuration data to drivers.</p>
<p>System-on-Chip (SOC) processors heavily rely on GPIOs.  In some cases, every
non-dedicated pin can be configured as a GPIO; and most chips have at least
several dozen of them.  Programmable logic devices (like FPGAs) can easily
provide GPIOs; multifunction chips like power managers, and audio codecs
often have a few such pins to help with pin scarcity on SOCs; and there are
also &#8220;GPIO Expander&#8221; chips that connect using the I2C or SPI serial busses.
Most PC southbridges have a few dozen GPIO-capable pins (with only the BIOS
firmware knowing how they&#8217;re used).</p>
<p>The exact capabilities of GPIOs vary between systems.  Common options:</p>
<blockquote>
<div><ul class="simple">
<li>Output values are writable (high=1, low=0).  Some chips also have
options about how that value is driven, so that for example only one
value might be driven ... supporting &#8220;wire-OR&#8221; and similar schemes
for the other value (notably, &#8220;open drain&#8221; signaling).</li>
<li>Input values are likewise readable (1, 0).  Some chips support readback
of pins configured as &#8220;output&#8221;, which is very useful in such &#8220;wire-OR&#8221;
cases (to support bidirectional signaling).  GPIO controllers may have
input de-glitch/debounce logic, sometimes with software controls.</li>
<li>Inputs can often be used as IRQ signals, often edge triggered but
sometimes level triggered.  Such IRQs may be configurable as system
wakeup events, to wake the system from a low power state.</li>
<li>Usually a GPIO will be configurable as either input or output, as needed
by different product boards; single direction ones exist too.</li>
<li>Most GPIOs can be accessed while holding spinlocks, but those accessed
through a serial bus normally can&#8217;t.  Some systems support both types.</li>
</ul>
</div></blockquote>
<p>On a given board each GPIO is used for one specific purpose like monitoring
MMC/SD card insertion/removal, detecting card writeprotect status, driving
a LED, configuring a transceiver, bitbanging a serial bus, poking a hardware
watchdog, sensing a switch, and so on.</p>
</div>
<div class="section" id="gpio-conventions">
<h2>5.2. GPIO conventions<a class="headerlink" href="#gpio-conventions" title="永久链接至标题">¶</a></h2>
<p>Note that this is called a &#8220;convention&#8221; because you don&#8217;t need to do it this
way, and it&#8217;s no crime if you don&#8217;t.  There <strong>are</strong> cases where portability
is not the main issue; GPIOs are often used for the kind of board-specific
glue logic that may even change between board revisions, and can&#8217;t ever be
used on a board that&#8217;s wired differently.  Only least-common-denominator
functionality can be very portable.  Other features are platform-specific,
and that can be critical for glue logic.</p>
<p>Plus, this doesn&#8217;t require any implementation framework, just an interface.
One platform might implement it as simple inline functions accessing chip
registers; another might implement it by delegating through abstractions
used for several very different kinds of GPIO controller.  (There is some
optional code supporting such an implementation strategy, described later
in this document, but drivers acting as clients to the GPIO interface must
not care how it&#8217;s implemented.)</p>
<p>That said, if the convention is supported on their platform, drivers should
use it when possible.  Platforms must select ARCH_REQUIRE_GPIOLIB or
ARCH_WANT_OPTIONAL_GPIOLIB in their Kconfig.  Drivers that can&#8217;t work without
standard GPIO calls should have Kconfig entries which depend on GPIOLIB.  The
GPIO calls are available, either as &#8220;real code&#8221; or as optimized-away stubs,
when drivers use the include file:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;linux/gpio.h&gt;</span>
</pre></div>
</div>
<p>If you stick to this convention then it&#8217;ll be easier for other developers to
see what your code is doing, and help maintain it.</p>
<p>Note that these operations include I/O barriers on platforms which need to
use them; drivers don&#8217;t need to add them explicitly.</p>
<div class="section" id="identifying-gpios">
<h3>5.2.1. Identifying GPIOs<a class="headerlink" href="#identifying-gpios" title="永久链接至标题">¶</a></h3>
<p>GPIOs are identified by unsigned integers in the range 0..MAX_INT.  That
reserves &#8220;negative&#8221; numbers for other purposes like marking signals as
&#8220;not available on this board&#8221;, or indicating faults.  Code that doesn&#8217;t
touch the underlying hardware treats these integers as opaque cookies.</p>
<p>Platforms define how they use those integers, and usually #define symbols
for the GPIO lines so that board-specific setup code directly corresponds
to the relevant schematics.  In contrast, drivers should only use GPIO
numbers passed to them from that setup code, using platform_data to hold
board-specific pin configuration data (along with other board specific
data they need).  That avoids portability problems.</p>
<p>So for example one platform uses numbers 32-159 for GPIOs; while another
uses numbers 0..63 with one set of GPIO controllers, 64-79 with another
type of GPIO controller, and on one particular board 80-95 with an FPGA.
The numbers need not be contiguous; either of those platforms could also
use numbers 2000-2063 to identify GPIOs in a bank of I2C GPIO expanders.</p>
<p>If you want to initialize a structure with an invalid GPIO number, use
some negative number (perhaps &#8220;-EINVAL&#8221;); that will never be valid.  To
test if such number from such a structure could reference a GPIO, you
may use this predicate:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">gpio_is_valid</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">);</span>
</pre></div>
</div>
<p>A number that&#8217;s not valid will be rejected by calls which may request
or free GPIOs (see below).  Other numbers may also be rejected; for
example, a number might be valid but temporarily unused on a given board.</p>
<p>Whether a platform supports multiple GPIO controllers is a platform-specific
implementation issue, as are whether that support can leave &#8220;holes&#8221; in the space
of GPIO numbers, and whether new controllers can be added at runtime.  Such issues
can affect things including whether adjacent GPIO numbers are both valid.</p>
</div>
<div class="section" id="using-gpios">
<h3>5.2.2. Using GPIOs<a class="headerlink" href="#using-gpios" title="永久链接至标题">¶</a></h3>
<p>The first thing a system should do with a GPIO is allocate it, using
the gpio_request() call; see later.</p>
<p>One of the next things to do with a GPIO, often in board setup code when
setting up a platform_device using the GPIO, is mark its direction:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* set as input or output, returning 0 or negative errno */</span>
<span class="kt">int</span> <span class="nf">gpio_direction_input</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">gpio_direction_output</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>The return value is zero for success, else a negative errno.  It should
be checked, since the get/set calls don&#8217;t have error returns and since
misconfiguration is possible.  You should normally issue these calls from
a task context.  However, for spinlock-safe GPIOs it&#8217;s OK to use them
before tasking is enabled, as part of early board setup.</p>
<p>For output GPIOs, the value provided becomes the initial output value.
This helps avoid signal glitching during system startup.</p>
<p>For compatibility with legacy interfaces to GPIOs, setting the direction
of a GPIO implicitly requests that GPIO (see below) if it has not been
requested already.  That compatibility is being removed from the optional
gpiolib framework.</p>
<p>Setting the direction can fail if the GPIO number is invalid, or when
that particular GPIO can&#8217;t be used in that mode.  It&#8217;s generally a bad
idea to rely on boot firmware to have set the direction correctly, since
it probably wasn&#8217;t validated to do more than boot Linux.  (Similarly,
that board setup code probably needs to multiplex that pin as a GPIO,
and configure pullups/pulldowns appropriately.)</p>
</div>
<div class="section" id="spinlock-safe-gpio-access">
<h3>5.2.3. Spinlock-Safe GPIO access<a class="headerlink" href="#spinlock-safe-gpio-access" title="永久链接至标题">¶</a></h3>
<p>Most GPIO controllers can be accessed with memory read/write instructions.
Those don&#8217;t need to sleep, and can safely be done from inside hard
(nonthreaded) IRQ handlers and similar contexts.</p>
<p>Use the following calls to access such GPIOs,
for which gpio_cansleep() will always return false (see below):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* GPIO INPUT:  return zero or nonzero */</span>
<span class="kt">int</span> <span class="nf">gpio_get_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">);</span>

<span class="cm">/* GPIO OUTPUT */</span>
<span class="kt">void</span> <span class="nf">gpio_set_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>The values are boolean, zero for low, nonzero for high.  When reading the
value of an output pin, the value returned should be what&#8217;s seen on the
pin ... that won&#8217;t always match the specified output value, because of
issues including open-drain signaling and output latencies.</p>
<p>The get/set calls have no error returns because &#8220;invalid GPIO&#8221; should have
been reported earlier from <tt class="docutils literal"><span class="pre">gpio_direction_*()</span></tt>.  However, note that not all
platforms can read the value of output pins; those that can&#8217;t should always
return zero.  Also, using these calls for GPIOs that can&#8217;t safely be accessed
without sleeping (see below) is an error.</p>
<p>Platform-specific implementations are encouraged to optimize the two
calls to access the GPIO value in cases where the GPIO number (and for
output, value) are constant.  It&#8217;s normal for them to need only a couple
of instructions in such cases (reading or writing a hardware register),
and not to need spinlocks.  Such optimized calls can make bitbanging
applications a lot more efficient (in both space and time) than spending
dozens of instructions on subroutine calls.</p>
</div>
<div class="section" id="gpio-access-that-may-sleep">
<h3>5.2.4. GPIO access that may sleep<a class="headerlink" href="#gpio-access-that-may-sleep" title="永久链接至标题">¶</a></h3>
<p>Some GPIO controllers must be accessed using message based busses like I2C
or SPI.  Commands to read or write those GPIO values require waiting to
get to the head of a queue to transmit a command and get its response.
This requires sleeping, which can&#8217;t be done from inside IRQ handlers.</p>
<p>Platforms that support this type of GPIO distinguish them from other GPIOs
by returning nonzero from this call (which requires a valid GPIO number,
which should have been previously allocated with gpio_request):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">gpio_cansleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">);</span>
</pre></div>
</div>
<p>To access such GPIOs, a different set of accessors is defined:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* GPIO INPUT:  return zero or nonzero, might sleep */</span>
<span class="kt">int</span> <span class="nf">gpio_get_value_cansleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">);</span>

<span class="cm">/* GPIO OUTPUT, might sleep */</span>
<span class="kt">void</span> <span class="nf">gpio_set_value_cansleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>Accessing such GPIOs requires a context which may sleep,  for example
a threaded IRQ handler, and those accessors must be used instead of
spinlock-safe accessors without the cansleep() name suffix.</p>
<p>Other than the fact that these accessors might sleep, and will work
on GPIOs that can&#8217;t be accessed from hardIRQ handlers, these calls act
the same as the spinlock-safe calls.</p>
<blockquote>
<div>** IN ADDITION ** calls to setup and configure such GPIOs must be made</div></blockquote>
<p>from contexts which may sleep, since they may need to access the GPIO
controller chip too:  (These setup calls are usually made from board
setup or driver probe/teardown code, so this is an easy constraint.)</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">gpio_direction_input</span><span class="p">()</span>
<span class="n">gpio_direction_output</span><span class="p">()</span>
<span class="n">gpio_request</span><span class="p">()</span>

<span class="cp">##      gpio_request_one()</span>
<span class="cp">##      gpio_request_array()</span>
<span class="cp">##      gpio_free_array()</span>

<span class="n">gpio_free</span><span class="p">()</span>
<span class="n">gpio_set_debounce</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="claiming-and-releasing-gpios">
<h3>5.2.5. Claiming and Releasing GPIOs<a class="headerlink" href="#claiming-and-releasing-gpios" title="永久链接至标题">¶</a></h3>
<p>To help catch system configuration errors, two calls are defined.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* request GPIO, returning 0 or negative errno.</span>
<span class="cm"> * non-null labels may be useful for diagnostics.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_request</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">);</span>

<span class="cm">/* release previously-claimed GPIO */</span>
<span class="kt">void</span> <span class="nf">gpio_free</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">);</span>
</pre></div>
</div>
<p>Passing invalid GPIO numbers to gpio_request() will fail, as will requesting
GPIOs that have already been claimed with that call.  The return value of
gpio_request() must be checked.  You should normally issue these calls from
a task context.  However, for spinlock-safe GPIOs it&#8217;s OK to request GPIOs
before tasking is enabled, as part of early board setup.</p>
<p>These calls serve two basic purposes.  One is marking the signals which
are actually in use as GPIOs, for better diagnostics; systems may have
several hundred potential GPIOs, but often only a dozen are used on any
given board.  Another is to catch conflicts, identifying errors when
(a) two or more drivers wrongly think they have exclusive use of that
signal, or (b) something wrongly believes it&#8217;s safe to remove drivers
needed to manage a signal that&#8217;s in active use.  That is, requesting a
GPIO can serve as a kind of lock.</p>
<p>Some platforms may also use knowledge about what GPIOs are active for
power management, such as by powering down unused chip sectors and, more
easily, gating off unused clocks.</p>
<p>For GPIOs that use pins known to the pinctrl subsystem, that subsystem should
be informed of their use; a gpiolib driver&#8217;s .request() operation may call
pinctrl_request_gpio(), and a gpiolib driver&#8217;s .free() operation may call
pinctrl_free_gpio(). The pinctrl subsystem allows a pinctrl_request_gpio()
to succeed concurrently with a pin or pingroup being &#8220;owned&#8221; by a device for
pin multiplexing.</p>
<p>Any programming of pin multiplexing hardware that is needed to route the
GPIO signal to the appropriate pin should occur within a GPIO driver&#8217;s
.direction_input() or .direction_output() operations, and occur after any
setup of an output GPIO&#8217;s value. This allows a glitch-free migration from a
pin&#8217;s special function to GPIO. This is sometimes required when using a GPIO
to implement a workaround on signals typically driven by a non-GPIO HW block.</p>
<p>Some platforms allow some or all GPIO signals to be routed to different pins.
Similarly, other aspects of the GPIO or pin may need to be configured, such as
pullup/pulldown. Platform software should arrange that any such details are
configured prior to gpio_request() being called for those GPIOs, e.g. using
the pinctrl subsystem&#8217;s mapping table, so that GPIO users need not be aware
of these details.</p>
<p>Also note that it&#8217;s your responsibility to have stopped using a GPIO
before you free it.</p>
<p>Considering in most cases GPIOs are actually configured right after they
are claimed, three additional calls are defined:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* request a single GPIO, with initial configuration specified by</span>
<span class="cm"> * &#39;flags&#39;, identical to gpio_request() wrt other arguments and</span>
<span class="cm"> * return value</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_request_one</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">);</span>

<span class="cm">/* request multiple GPIOs in a single call</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_request_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num</span><span class="p">);</span>

<span class="cm">/* release multiple GPIOs in a single call</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gpio_free_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num</span><span class="p">);</span>
</pre></div>
</div>
<p>where &#8216;flags&#8217; is currently defined to specify the following properties:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">*</span> <span class="n">GPIOF_DIR_IN</span>          <span class="o">-</span> <span class="n">to</span> <span class="n">configure</span> <span class="n">direction</span> <span class="n">as</span> <span class="n">input</span>
<span class="o">*</span> <span class="n">GPIOF_DIR_OUT</span>         <span class="o">-</span> <span class="n">to</span> <span class="n">configure</span> <span class="n">direction</span> <span class="n">as</span> <span class="n">output</span>

<span class="o">*</span> <span class="n">GPIOF_INIT_LOW</span>        <span class="o">-</span> <span class="n">as</span> <span class="n">output</span><span class="p">,</span> <span class="n">set</span> <span class="n">initial</span> <span class="n">level</span> <span class="n">to</span> <span class="n">LOW</span>
<span class="o">*</span> <span class="n">GPIOF_INIT_HIGH</span>       <span class="o">-</span> <span class="n">as</span> <span class="n">output</span><span class="p">,</span> <span class="n">set</span> <span class="n">initial</span> <span class="n">level</span> <span class="n">to</span> <span class="n">HIGH</span>
<span class="o">*</span> <span class="n">GPIOF_OPEN_DRAIN</span>      <span class="o">-</span> <span class="n">gpio</span> <span class="n">pin</span> <span class="n">is</span> <span class="n">open</span> <span class="n">drain</span> <span class="n">type</span><span class="p">.</span>
<span class="o">*</span> <span class="n">GPIOF_OPEN_SOURCE</span>     <span class="o">-</span> <span class="n">gpio</span> <span class="n">pin</span> <span class="n">is</span> <span class="n">open</span> <span class="n">source</span> <span class="n">type</span><span class="p">.</span>

<span class="o">*</span> <span class="n">GPIOF_EXPORT_DIR_FIXED</span>        <span class="o">-</span> <span class="n">export</span> <span class="n">gpio</span> <span class="n">to</span> <span class="n">sysfs</span><span class="p">,</span> <span class="n">keep</span> <span class="n">direction</span>
<span class="o">*</span> <span class="n">GPIOF_EXPORT_DIR_CHANGEABLE</span>   <span class="o">-</span> <span class="n">also</span> <span class="n">export</span><span class="p">,</span> <span class="n">allow</span> <span class="n">changing</span> <span class="n">direction</span>
</pre></div>
</div>
<p>since <tt class="docutils literal"><span class="pre">GPIOF_INIT_*</span></tt> are only valid when configured as output, so group valid
combinations as:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="o">*</span> <span class="n">GPIOF_IN</span>              <span class="o">-</span> <span class="n">configure</span> <span class="n">as</span> <span class="n">input</span>
<span class="o">*</span> <span class="n">GPIOF_OUT_INIT_LOW</span>    <span class="o">-</span> <span class="n">configured</span> <span class="n">as</span> <span class="n">output</span><span class="p">,</span> <span class="n">initial</span> <span class="n">level</span> <span class="n">LOW</span>
<span class="o">*</span> <span class="n">GPIOF_OUT_INIT_HIGH</span>   <span class="o">-</span> <span class="n">configured</span> <span class="n">as</span> <span class="n">output</span><span class="p">,</span> <span class="n">initial</span> <span class="n">level</span> <span class="n">HIGH</span>
</pre></div>
</div>
<p>When setting the flag as GPIOF_OPEN_DRAIN then it will assume that pins is
open drain type. Such pins will not be driven to 1 in output mode. It is
require to connect pull-up on such pins. By enabling this flag, gpio lib will
make the direction to input when it is asked to set value of 1 in output mode
to make the pin HIGH. The pin is make to LOW by driving value 0 in output mode.</p>
<p>When setting the flag as GPIOF_OPEN_SOURCE then it will assume that pins is
open source type. Such pins will not be driven to 0 in output mode. It is
require to connect pull-down on such pin. By enabling this flag, gpio lib will
make the direction to input when it is asked to set value of 0 in output mode
to make the pin LOW. The pin is make to HIGH by driving value 1 in output mode.</p>
<p>In the future, these flags can be extended to support more properties.</p>
<p>Further more, to ease the claim/release of multiple GPIOs, &#8216;struct gpio&#8217; is
introduced to encapsulate all three fields as:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">gpio</span> <span class="p">{</span>
        <span class="kt">unsigned</span>        <span class="n">gpio</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">flags</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span>      <span class="o">*</span><span class="n">label</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A typical example of usage:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="k">struct</span> <span class="n">gpio</span> <span class="n">leds_gpios</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="mi">32</span><span class="p">,</span> <span class="n">GPIOF_OUT_INIT_HIGH</span><span class="p">,</span> <span class="s">&quot;Power LED&quot;</span> <span class="p">},</span> <span class="cm">/* default to ON */</span>
        <span class="p">{</span> <span class="mi">33</span><span class="p">,</span> <span class="n">GPIOF_OUT_INIT_LOW</span><span class="p">,</span>  <span class="s">&quot;Green LED&quot;</span> <span class="p">},</span> <span class="cm">/* default to OFF */</span>
        <span class="p">{</span> <span class="mi">34</span><span class="p">,</span> <span class="n">GPIOF_OUT_INIT_LOW</span><span class="p">,</span>  <span class="s">&quot;Red LED&quot;</span>   <span class="p">},</span> <span class="cm">/* default to OFF */</span>
        <span class="p">{</span> <span class="mi">35</span><span class="p">,</span> <span class="n">GPIOF_OUT_INIT_LOW</span><span class="p">,</span>  <span class="s">&quot;Blue LED&quot;</span>  <span class="p">},</span> <span class="cm">/* default to OFF */</span>
        <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="p">};</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_request_one</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="n">GPIOF_IN</span><span class="p">,</span> <span class="s">&quot;Reset Button&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="p">...</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_request_array</span><span class="p">(</span><span class="n">leds_gpios</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">leds_gpios</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="p">...</span>

<span class="n">gpio_free_array</span><span class="p">(</span><span class="n">leds_gpios</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">leds_gpios</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="gpios-mapped-to-irqs">
<h3>5.2.6. GPIOs mapped to IRQs<a class="headerlink" href="#gpios-mapped-to-irqs" title="永久链接至标题">¶</a></h3>
<p>GPIO numbers are unsigned integers; so are IRQ numbers.  These make up
two logically distinct namespaces (GPIO 0 need not use IRQ 0).  You can
map between them using calls like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* map GPIO numbers to IRQ numbers */</span>
<span class="kt">int</span> <span class="nf">gpio_to_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">);</span>

<span class="cm">/* map IRQ numbers to GPIO numbers (avoid using this) */</span>
<span class="kt">int</span> <span class="nf">irq_to_gpio</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">irq</span><span class="p">);</span>
</pre></div>
</div>
<p>Those return either the corresponding number in the other namespace, or
else a negative errno code if the mapping can&#8217;t be done.  (For example,
some GPIOs can&#8217;t be used as IRQs.)  It is an unchecked error to use a GPIO
number that wasn&#8217;t set up as an input using gpio_direction_input(), or
to use an IRQ number that didn&#8217;t originally come from gpio_to_irq().</p>
<p>These two mapping calls are expected to cost on the order of a single
addition or subtraction.  They&#8217;re not allowed to sleep.</p>
<p>Non-error values returned from gpio_to_irq() can be passed to request_irq()
or free_irq().  They will often be stored into IRQ resources for platform
devices, by the board-specific initialization code.  Note that IRQ trigger
options are part of the IRQ interface, e.g. IRQF_TRIGGER_FALLING, as are
system wakeup capabilities.</p>
<p>Non-error values returned from irq_to_gpio() would most commonly be used
with gpio_get_value(), for example to initialize or update driver state
when the IRQ is edge-triggered.  Note that some platforms don&#8217;t support
this reverse mapping, so you should avoid using it.</p>
</div>
<div class="section" id="emulating-open-drain-signals">
<h3>5.2.7. Emulating Open Drain Signals<a class="headerlink" href="#emulating-open-drain-signals" title="永久链接至标题">¶</a></h3>
<p>Sometimes shared signals need to use &#8220;open drain&#8221; signaling, where only the
low signal level is actually driven.  (That term applies to CMOS transistors;
&#8220;open collector&#8221; is used for TTL.)  A pullup resistor causes the high signal
level.  This is sometimes called a &#8220;wire-AND&#8221;; or more practically, from the
negative logic (low=true) perspective this is a &#8220;wire-OR&#8221;.</p>
<p>One common example of an open drain signal is a shared active-low IRQ line.
Also, bidirectional data bus signals sometimes use open drain signals.</p>
<p>Some GPIO controllers directly support open drain outputs; many don&#8217;t.  When
you need open drain signaling but your hardware doesn&#8217;t directly support it,
there&#8217;s a common idiom you can use to emulate it with any GPIO pin that can
be used as either an input or an output:</p>
<ul>
<li><dl class="first docutils">
<dt>LOW:</dt>
<dd><p class="first last">gpio_direction_output(gpio, 0) ... this drives the signal and overrides the pullup.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>HIGH</dt>
<dd><p class="first last">gpio_direction_input(gpio) ... this turns off the output, so the pullup (or some other device) controls the signal.</p>
</dd>
</dl>
</li>
</ul>
<p>If you are &#8220;driving&#8221; the signal high but gpio_get_value(gpio) reports a low
value (after the appropriate rise time passes), you know some other component
is driving the shared signal low.  That&#8217;s not necessarily an error.  As one
common example, that&#8217;s how I2C clocks are stretched:  a slave that needs a
slower clock delays the rising edge of SCK, and the I2C master adjusts its
signaling rate accordingly.</p>
</div>
<div class="section" id="gpio-controllers-and-the-pinctrl-subsystem">
<h3>5.2.8. GPIO controllers and the pinctrl subsystem<a class="headerlink" href="#gpio-controllers-and-the-pinctrl-subsystem" title="永久链接至标题">¶</a></h3>
<p>A GPIO controller on a SOC might be tightly coupled with the pinctrl
subsystem, in the sense that the pins can be used by other functions
together with an optional gpio feature. We have already covered the
case where e.g. a GPIO controller need to reserve a pin or set the
direction of a pin by calling any of:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">pinctrl_request_gpio</span><span class="p">()</span>
<span class="n">pinctrl_free_gpio</span><span class="p">()</span>
<span class="n">pinctrl_gpio_direction_input</span><span class="p">()</span>
<span class="n">pinctrl_gpio_direction_output</span><span class="p">()</span>
</pre></div>
</div>
<p>But how does the pin control subsystem cross-correlate the GPIO
numbers (which are a global business) to a certain pin on a certain
pin controller?</p>
<p>This is done by registering &#8220;ranges&#8221; of pins, which are essentially
cross-reference tables. These are described in
Documentation/pinctrl.txt</p>
<p>While the pin allocation is totally managed by the pinctrl subsystem,
gpio (under gpiolib) is still maintained by gpio drivers. It may happen
that different pin ranges in a SoC is managed by different gpio drivers.</p>
<p>This makes it logical to let gpio drivers announce their pin ranges to
the pin ctrl subsystem before it will call &#8216;pinctrl_request_gpio&#8217; in order
to request the corresponding pin to be prepared by the pinctrl subsystem
before any gpio usage.</p>
<p>For this, the gpio controller can register its pin range with pinctrl
subsystem. There are two ways of doing it currently: with or without DT.</p>
<p>For with DT support refer to Documentation/devicetree/bindings/gpio/gpio.txt.</p>
<p>For non-DT support, user can call gpiochip_add_pin_range() with appropriate
parameters to register a range of gpio pins with a pinctrl driver. For this
exact name string of pinctrl device has to be passed as one of the
argument to this routine.</p>
</div>
</div>
<div class="section" id="what-do-these-conventions-omit">
<h2>5.3. What do these conventions omit?<a class="headerlink" href="#what-do-these-conventions-omit" title="永久链接至标题">¶</a></h2>
<p>One of the biggest things these conventions omit is pin multiplexing, since
this is highly chip-specific and nonportable.  One platform might not need
explicit multiplexing; another might have just two options for use of any
given pin; another might have eight options per pin; another might be able
to route a given GPIO to any one of several pins.  (Yes, those examples all
come from systems that run Linux today.)</p>
<p>Related to multiplexing is configuration and enabling of the pullups or
pulldowns integrated on some platforms.  Not all platforms support them,
or support them in the same way; and any given board might use external
pullups (or pulldowns) so that the on-chip ones should not be used.
(When a circuit needs 5 kOhm, on-chip 100 kOhm resistors won&#8217;t do.)
Likewise drive strength (2 mA vs 20 mA) and voltage (1.8V vs 3.3V) is a
platform-specific issue, as are models like (not) having a one-to-one
correspondence between configurable pins and GPIOs.</p>
<p>There are other system-specific mechanisms that are not specified here,
like the aforementioned options for input de-glitching and wire-OR output.
Hardware may support reading or writing GPIOs in gangs, but that&#8217;s usually
configuration dependent:  for GPIOs sharing the same bank.  (GPIOs are
commonly grouped in banks of 16 or 32, with a given SOC having several such
banks.)  Some systems can trigger IRQs from output GPIOs, or read values
from pins not managed as GPIOs.  Code relying on such mechanisms will
necessarily be nonportable.</p>
<p>Dynamic definition of GPIOs is not currently standard; for example, as
a side effect of configuring an add-on board with some GPIO expanders.</p>
</div>
<div class="section" id="gpio-implementor-s-framework-optional">
<h2>5.4. GPIO implementor&#8217;s framework (OPTIONAL)<a class="headerlink" href="#gpio-implementor-s-framework-optional" title="永久链接至标题">¶</a></h2>
<p>As noted earlier, there is an optional implementation framework making it
easier for platforms to support different kinds of GPIO controller using
the same programming interface.  This framework is called &#8220;gpiolib&#8221;.</p>
<p>As a debugging aid, if debugfs is available a /sys/kernel/debug/gpio file
will be found there.  That will list all the controllers registered through
this framework, and the state of the GPIOs currently in use.</p>
<div class="section" id="controller-drivers-gpio-chip">
<h3>5.4.1. Controller Drivers: gpio_chip<a class="headerlink" href="#controller-drivers-gpio-chip" title="永久链接至标题">¶</a></h3>
<p>In this framework each GPIO controller is packaged as a &#8220;struct gpio_chip&#8221;
with information common to each controller of that type:</p>
<blockquote>
<div><ul class="simple">
<li>methods to establish GPIO direction</li>
<li>methods used to access GPIO values</li>
<li>flag saying whether calls to its methods may sleep</li>
<li>optional debugfs dump method (showing extra state like pullup config)</li>
<li>label for diagnostics</li>
</ul>
</div></blockquote>
<p>There is also per-instance data, which may come from device.platform_data:
the number of its first GPIO, and how many GPIOs it exposes.</p>
<p>The code implementing a gpio_chip should support multiple instances of the
controller, possibly using the driver model.  That code will configure each
gpio_chip and issue gpiochip_add().  Removing a GPIO controller should be
rare; use gpiochip_remove() when it is unavoidable.</p>
<p>Most often a gpio_chip is part of an instance-specific structure with state
not exposed by the GPIO interfaces, such as addressing, power management,
and more.  Chips such as codecs will have complex non-GPIO state.</p>
<p>Any debugfs dump method should normally ignore signals which haven&#8217;t been
requested as GPIOs.  They can use gpiochip_is_requested(), which returns
either NULL or the label associated with that GPIO when it was requested.</p>
</div>
<div class="section" id="platform-support">
<h3>5.4.2. Platform Support<a class="headerlink" href="#platform-support" title="永久链接至标题">¶</a></h3>
<p>To support this framework, a platform&#8217;s Kconfig will &#8220;select&#8221; either
ARCH_REQUIRE_GPIOLIB or ARCH_WANT_OPTIONAL_GPIOLIB
and arrange that its &lt;asm/gpio.h&gt; includes &lt;asm-generic/gpio.h&gt; and defines
three functions: gpio_get_value(), gpio_set_value(), and gpio_cansleep().</p>
<p>It may also provide a custom value for ARCH_NR_GPIOS, so that it better
reflects the number of GPIOs in actual use on that platform, without
wasting static table space.  (It should count both built-in/SoC GPIOs and
also ones on GPIO expanders.</p>
<p>ARCH_REQUIRE_GPIOLIB means that the gpiolib code will always get compiled
into the kernel on that architecture.</p>
<p>ARCH_WANT_OPTIONAL_GPIOLIB means the gpiolib code defaults to off and the user
can enable it and build it into the kernel optionally.</p>
<p>If neither of these options are selected, the platform does not support
GPIOs through GPIO-lib and the code cannot be enabled by the user.</p>
<p>Trivial implementations of those functions can directly use framework
code, which always dispatches through the gpio_chip:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define gpio_get_value        __gpio_get_value</span>
<span class="cp">#define gpio_set_value        __gpio_set_value</span>
<span class="cp">#define gpio_cansleep         __gpio_cansleep</span>
</pre></div>
</div>
<p>Fancier implementations could instead define those as inline functions with
logic optimizing access to specific SOC-based GPIOs.  For example, if the
referenced GPIO is the constant &#8220;12&#8221;, getting or setting its value could
cost as little as two or three instructions, never sleeping.  When such an
optimization is not possible those calls must delegate to the framework
code, costing at least a few dozen instructions.  For bitbanged I/O, such
instruction savings can be significant.</p>
<p>For SOCs, platform-specific code defines and registers gpio_chip instances
for each bank of on-chip GPIOs.  Those GPIOs should be numbered/labeled to
match chip vendor documentation, and directly match board schematics.  They
may well start at zero and go up to a platform-specific limit.  Such GPIOs
are normally integrated into platform initialization to make them always be
available, from arch_initcall() or earlier; they can often serve as IRQs.</p>
</div>
<div class="section" id="board-support">
<h3>5.4.3. Board Support<a class="headerlink" href="#board-support" title="永久链接至标题">¶</a></h3>
<p>For external GPIO controllers &#8211; such as I2C or SPI expanders, ASICs, multi
function devices, FPGAs or CPLDs &#8211; most often board-specific code handles
registering controller devices and ensures that their drivers know what GPIO
numbers to use with gpiochip_add().  Their numbers often start right after
platform-specific GPIOs.</p>
<p>For example, board setup code could create structures identifying the range
of GPIOs that chip will expose, and passes them to each GPIO expander chip
using platform_data.  Then the chip driver&#8217;s probe() routine could pass that
data to gpiochip_add().</p>
<p>Initialization order can be important.  For example, when a device relies on
an I2C-based GPIO, its probe() routine should only be called after that GPIO
becomes available.  That may mean the device should not be registered until
calls for that GPIO can work.  One way to address such dependencies is for
such gpio_chip controllers to provide setup() and teardown() callbacks to
board specific code; those board specific callbacks would register devices
once all the necessary resources are available, and remove them later when
the GPIO controller device becomes unavailable.</p>
</div>
</div>
<div class="section" id="sysfs-interface-for-userspace-optional">
<h2>5.5. Sysfs Interface for Userspace (OPTIONAL)<a class="headerlink" href="#sysfs-interface-for-userspace-optional" title="永久链接至标题">¶</a></h2>
<p>Platforms which use the &#8220;gpiolib&#8221; implementors framework may choose to
configure a sysfs user interface to GPIOs.  This is different from the
debugfs interface, since it provides control over GPIO direction and
value instead of just showing a gpio state summary.  Plus, it could be
present on production systems without debugging support.</p>
<p>Given appropriate hardware documentation for the system, userspace could
know for example that GPIO #23 controls the write protect line used to
protect boot loader segments in flash memory.  System upgrade procedures
may need to temporarily remove that protection, first importing a GPIO,
then changing its output state, then updating the code before re-enabling
the write protection.  In normal use, GPIO #23 would never be touched,
and the kernel would have no need to know about it.</p>
<p>Again depending on appropriate hardware documentation, on some systems
userspace GPIO can be used to determine system configuration data that
standard kernels won&#8217;t know about.  And for some tasks, simple userspace
GPIO drivers could be all that the system really needs.</p>
<p>Note that standard kernel drivers exist for common &#8220;LEDs and Buttons&#8221;
GPIO tasks:  &#8220;leds-gpio&#8221; and &#8220;gpio_keys&#8221;, respectively.  Use those
instead of talking directly to the GPIOs; they integrate with kernel
frameworks better than your userspace code could.</p>
<div class="section" id="paths-in-sysfs">
<h3>5.5.1. Paths in Sysfs<a class="headerlink" href="#paths-in-sysfs" title="永久链接至标题">¶</a></h3>
<p>There are three kinds of entry in /sys/class/gpio:</p>
<ul class="simple">
<li>Control interfaces used to get userspace control over GPIOs;</li>
<li>GPIOs themselves;</li>
<li>GPIO controllers (&#8220;gpio_chip&#8221; instances).</li>
</ul>
<p>That&#8217;s in addition to standard files including the &#8220;device&#8221; symlink.</p>
<p>The control interfaces are write-only:</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">/sys/class/gpio/</span></tt></p>
<blockquote>
<div><dl class="docutils">
<dt>&#8220;export&#8221; ... Userspace may ask the kernel to export control of</dt>
<dd><p class="first">a GPIO to userspace by writing its number to this file.</p>
<p class="last">Example:  &#8220;echo 19 &gt; export&#8221; will create a &#8220;gpio19&#8221; node
for GPIO #19, if that&#8217;s not requested by kernel code.</p>
</dd>
</dl>
<p>&#8220;unexport&#8221; ... Reverses the effect of exporting to userspace.</p>
<blockquote>
<div>Example:  &#8220;echo 19 &gt; unexport&#8221; will remove a &#8220;gpio19&#8221;
node exported using the &#8220;export&#8221; file.</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>GPIO signals have paths like /sys/class/gpio/gpio42/ (for GPIO #42)
and have the following read/write attributes:</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">/sys/class/gpio/gpioN/</span></tt></p>
<blockquote>
<div><dl class="docutils">
<dt>&#8220;direction&#8221; ... reads as either &#8220;in&#8221; or &#8220;out&#8221;.  This value may</dt>
<dd><p class="first">normally be written.  Writing as &#8220;out&#8221; defaults to
initializing the value as low.  To ensure glitch free
operation, values &#8220;low&#8221; and &#8220;high&#8221; may be written to
configure the GPIO as an output with that initial value.</p>
<p class="last">Note that this attribute <em>will not exist</em> if the kernel
doesn&#8217;t support changing the direction of a GPIO, or
it was exported by kernel code that didn&#8217;t explicitly
allow userspace to reconfigure this GPIO&#8217;s direction.</p>
</dd>
<dt>&#8220;value&#8221; ... reads as either 0 (low) or 1 (high).  If the GPIO</dt>
<dd><p class="first">is configured as an output, this value may be written;
any nonzero value is treated as high.</p>
<p class="last">If the pin can be configured as interrupt-generating interrupt
and if it has been configured to generate interrupts (see the
description of &#8220;edge&#8221;), you can poll(2) on that file and
poll(2) will return whenever the interrupt was triggered. If
you use poll(2), set the events POLLPRI and POLLERR. If you
use select(2), set the file descriptor in exceptfds. After
poll(2) returns, either lseek(2) to the beginning of the sysfs
file and read the new value or close the file and re-open it
to read the value.</p>
</dd>
<dt>&#8220;edge&#8221; ... reads as either &#8220;none&#8221;, &#8220;rising&#8221;, &#8220;falling&#8221;, or</dt>
<dd><p class="first">&#8220;both&#8221;. Write these strings to select the signal edge(s)
that will make poll(2) on the &#8220;value&#8221; file return.</p>
<p class="last">This file exists only if the pin can be configured as an
interrupt generating input pin.</p>
</dd>
<dt>&#8220;active_low&#8221; ... reads as either 0 (false) or 1 (true).  Write</dt>
<dd>any nonzero value to invert the value attribute both
for reading and writing.  Existing and subsequent
poll(2) support configuration via the edge attribute
for &#8220;rising&#8221; and &#8220;falling&#8221; edges will follow this
setting.</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>GPIO controllers have paths like /sys/class/gpio/gpiochip42/ (for the
controller implementing GPIOs starting at #42) and have the following
read-only attributes:</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">/sys/class/gpio/gpiochipN/</span></tt></p>
<blockquote>
<div><p>&#8220;base&#8221; ... same as N, the first GPIO managed by this chip</p>
<p>&#8220;label&#8221; ... provided for diagnostics (not always unique)</p>
<p>&#8220;ngpio&#8221; ... how many GPIOs this manges (N to N + ngpio - 1)</p>
</div></blockquote>
</div></blockquote>
<p>Board documentation should in most cases cover what GPIOs are used for
what purposes.  However, those numbers are not always stable; GPIOs on
a daughtercard might be different depending on the base board being used,
or other cards in the stack.  In such cases, you may need to use the
gpiochip nodes (possibly in conjunction with schematics) to determine
the correct GPIO number to use for a given signal.</p>
</div>
<div class="section" id="exporting-from-kernel-code">
<h3>5.5.2. Exporting from Kernel code<a class="headerlink" href="#exporting-from-kernel-code" title="永久链接至标题">¶</a></h3>
<p>Kernel code can explicitly manage exports of GPIOs which have already been
requested using gpio_request():</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/* export the GPIO to userspace */</span>
<span class="kt">int</span> <span class="nf">gpio_export</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">direction_may_change</span><span class="p">);</span>

<span class="cm">/* reverse gpio_export() */</span>
<span class="kt">void</span> <span class="nf">gpio_unexport</span><span class="p">();</span>

<span class="cm">/* create a sysfs link to an exported GPIO node */</span>
<span class="kt">int</span> <span class="nf">gpio_export_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>

<span class="cm">/* change the polarity of a GPIO node in sysfs */</span>
<span class="kt">int</span> <span class="n">gpio_sysfs_set_active_low</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>After a kernel driver requests a GPIO, it may only be made available in
the sysfs interface by gpio_export().  The driver can control whether the
signal direction may change.  This helps drivers prevent userspace code
from accidentally clobbering important system state.</p>
<p>This explicit exporting can help with debugging (by making some kinds
of experiments easier), or can provide an always-there interface that&#8217;s
suitable for documenting as part of a board support package.</p>
<p>After the GPIO has been exported, gpio_export_link() allows creating
symlinks from elsewhere in sysfs to the GPIO sysfs node.  Drivers can
use this to provide the interface under their own device in sysfs with
a descriptive name.</p>
<p>Drivers can use gpio_sysfs_set_active_low() to hide GPIO line polarity
differences between boards from user space.  This only affects the
sysfs interface.  Polarity change can be done both before and after
gpio_export(), and previously enabled poll(2) support for either
rising or falling edge will be reconfigured to follow this setting.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">內容目录</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="C0_前言.html">1. 前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="C1_像单片机一样控制树莓派GPIO.html">2. 像单片机一样控制树莓派GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="C2_充满Linux风格地控制树莓派GPIO.html">3. 充满Linux风格地控制树莓派GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="C3_真正的GPIO内核驱动.html">4. 真正的GPIO内核驱动</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">5. 附录 - GPIO Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-a-gpio">5.1. What is a GPIO?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpio-conventions">5.2. GPIO conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#what-do-these-conventions-omit">5.3. What do these conventions omit?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpio-implementor-s-framework-optional">5.4. GPIO implementor&#8217;s framework (OPTIONAL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sysfs-interface-for-userspace-optional">5.5. Sysfs Interface for Userspace (OPTIONAL)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="附录-树莓派GPIO编号.html">6. 附录 - 树莓派GPIO编号</a></li>
<li class="toctree-l1"><a class="reference internal" href="附录-建立树莓派交叉编译环境.html">7. 附录 - 建立树莓派交叉编译环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="附录-交叉编译新内核和驱动模块.html">8. 附录 - 交叉编译新内核和驱动模块</a></li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="C3_真正的GPIO内核驱动.html"
                        title="上一章">4. 真正的GPIO内核驱动</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="附录-树莓派GPIO编号.html"
                        title="下一章">6. 附录 - 树莓派GPIO编号</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="sources/附录-GPIO Interfaces.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="附录-树莓派GPIO编号.html" title="6. 附录 - 树莓派GPIO编号"
             >下一页</a></li>
        <li class="right" >
          <a href="C3_真正的GPIO内核驱动.html" title="4. 真正的GPIO内核驱动"
             >上一页</a> |</li>
        <li><a href="index.html">简明 Linux GPIO驱动指导 1.0.0 文档</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; 版权所有 2014, 自由文档，由openRPi收集整理编辑.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2 创建。
    </div>
  </body>
</html>